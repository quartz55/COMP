options {
  STATIC = false;
}
PARSER_BEGIN(Scanner)

  public class Scanner {
    public static void main (String args[]) {

      //Parser initialization
      Scanner jscanner;
      int count_args = args.length;

      if(count_args == 0) {
        System.out.println ("Scanner: Waiting for input ...");
        jscanner = new Scanner(System.in);
      }
      else if(count_args >= 1) {
          for(int i = 0; i < count_args; i++) {
              System.out.println ("Scanner: Reading the file " + args[i] + " ..." );
              try {
                  jscanner = new Scanner(new java.io.FileInputStream(args[i]));
                  jscanner.Begin();
                  System.out.println ("Scanner: The input was read sucessfully.");
                  }
              catch(java.io.FileNotFoundException e) {
                  System.out.println ("Scanner: The file " + args[i] + " was not found.");
                  return;
                  }
              catch(ParseException e) {
                  System.out.println ("Scanner: There was an error during the parse.");
                  System.out.println (e.getMessage());
                  }
              catch(TokenMgrError e) {
                  System.out.println ("Scanner: There was an error.");
                  System.out.println (e.getMessage());
                  }
                 }
                }
      else {
        System.out.println ("Scanner:  You must use one of the following:");
        System.out.println ("\tjava Scanner < files");
        System.out.println ("Or");
        System.out.println ("\tjava Scanner files");
        return ;
      }
    }
  }

PARSER_END(Scanner)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"rem" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"//" (~["\n","\r"])*>
|  <"/*"> : MULTILINE_COMMENT_STATE
}

<MULTILINE_COMMENT_STATE> SKIP : {
  <"*/"> : DEFAULT
| <~[]>
}

//STATIC TOKENS
TOKEN : {
  <INTEGER_CONSTANT: (<PLUS> | <MINUS>)?(<DIGIT>)+>
| <FLOAT_CONSTANT: (<PLUS> | <MINUS>)?(<DIGIT>)+<DOT>(<DIGIT>)+>
| <LOGIC_CONSTANT: "true" | "false" | "-1">
| <STRING_CONSTANT: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ( ["\n","\r"] | "\r\n")))* "\"">
| <HEXADECIMAL_CONSTANT: "0"("x" | "X")(<LETTER> | <DIGIT>)+>
| <#DIGIT: ["0"-"9"]>

| <CLOSE01: "(">
| <CLOSE02: ")">
| <CLOSE11: "{">
| <CLOSE12: "}">
| <CLOSE21: "[">
| <CLOSE22: "]">

| <COMMA: ",">
| <DOT: ".">
| <SEMICOLON: ";">
| <COLON: ":">

| <EQUALS: "=">

| <CMPEQUALS: "==">
| <CMPNEQUALS: "!=">
| <AND: "&&">
| <OR: "||">
| <GTHAN: ">">
| <LTHAN: "<">

| <NOT: "!">

| <CONCAT: "&">
| <UNION: "|">

| <PLUS: "+">
| <MINUS: "-">
| <MULTIPLY: "*">
| <DIVIDE: "/">
}

//RESERVED WORDS
TOKEN : {
<ABSTRACT: "abstract">
| <ASSERT: "assert">
| <BOOLEAN: "boolean">
| <BREAK: "break">
| <BYTE: "byte">
| <CASE: "case">
| <CATCH: "catch">
| <CHAR: "char">
| <CLASS: "class">
| <CONST: "const">
| <CONTINUE: "continue">
| <DEFAULTR: "default">
| <DO: "do">
| <DOUBLE: "double">
| <ELSE: "else">
| <ENUM: "enum">
| <FINAL: "final">
| <FINALLY: "finally">
| <FLOAT: "float">
| <FOR: "for">
| <GOTO: "goto">
| <IF: "if">
| <IMPLEMENTS: "implements">
| <EXTENDS: "extends">
| <IMPORT: "import">
| <INSTANCEOF: "instanceof">
| <INT: "int">
| <INTERFACE: "interface">
| <LONG: "long">
| <NATIVE: "native">
| <NEW: "new">
| <PACKAGE: "package">
| <PRIVATE: "private">
| <PROTECTED: "protected">
| <PUBLIC: "public">
| <RETURN: "return">
| <SHORT: "short">
| <STATIC: "static">
| <STRICTFP: "strictfp">
| <SUPER: "super">
| <SWITCH: "switch">
| <SYNCHRONIZED: "synchronized">
| <THIS: "this">
| <THROW: "throw">
| <THROWS: "throws">
| <TRANSIENT: "transient">
| <TRY: "try">
| <VOID: "void">
| <VOLATILE: "volatile">
| <WHILE: "while">
| <NOTATION: "@"(["a"-"z","A"-"Z","0"-"9"])*>
}

//IDENTIFIER TOKEN
TOKEN : {
 <IDENTIFIER: (<LETTER> | "_")(<LETTER> | <DIGIT> | "_")*>
|  <#LETTER: (["a"-"z","A"-"Z"])>
}

TOKEN : {
 <OTHER: ~[]>
}

//MAIN UNIT
void Start () : {}
{
  (
    <INTEGER_CONSTANT> | <STRING_CONSTANT> | <LOGIC_CONSTANT> | <HEXADECIMAL_CONSTANT> |
    <CLOSE01> | <CLOSE02> | <CLOSE11> | <CLOSE12> | <CLOSE21> | <CLOSE22> |
    <COMMA> | <DOT> | <SEMICOLON> | <COLON> |
    <EQUALS> |
    <CMPEQUALS> | <CMPNEQUALS> | <AND> | <OR> | <GTHAN> | <LTHAN> |
    <NOT> |
    <CONCAT> | <UNION> |
    <PLUS> | <MINUS> | <MULTIPLY> | <DIVIDE> |
    <ABSTRACT> | <ASSERT> | <BOOLEAN> | <BREAK> | <BYTE> | <CASE> | <CATCH> | <CHAR> | <CLASS> | <CONST> | <CONTINUE> | <DEFAULTR> | <DO> | <DOUBLE> | <ELSE> | <ENUM> | <EXTENDS> | <FINAL> |
    <FINALLY> | <FLOAT> | <FOR> | <GOTO> | <IF> | <IMPLEMENTS> | <IMPORT> | <INSTANCEOF> | <INT> | <INTERFACE> | <LONG> | <NATIVE> | <NEW> | <PACKAGE> | <PRIVATE> | <PROTECTED> | <PUBLIC> |
    <RETURN> | <SHORT> | <STATIC> | <STRICTFP> | <SUPER> | <SWITCH> | <SYNCHRONIZED> | <THIS> | <THROW> | <THROWS> | <TRANSIENT> | <TRY> | <VOID> | <VOLATILE> | <WHILE> |
    <NOTATION> |
    <IDENTIFIER>
  )*
  <EOF>
}

void Begin () : {String mainClassName;}
{
(Package())?
(Import())*
mainClassName=ClassDecl()
<CLOSE11>
ClassScope(mainClassName)
<CLOSE12>
}

void Package () : {}
{
<PACKAGE> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>
}

void Import () : {}
{
<IMPORT> <IDENTIFIER>
(LOOKAHEAD(2) <DOT> <IDENTIFIER>)*
(<DOT> <MULTIPLY>)?
<SEMICOLON>
}

String ClassDecl () : {Token t;}
{
(Scope())? <CLASS>
t=<IDENTIFIER> {
    System.out.println("Found class \'"+t.image+"\'");
    return t.image;
    }
}

void ClassScope (String className) : {}
{
    {
        System.out.println("Enterning scope of \'"+className+"\'");
    }
(
    (Scope())? StorageType()
    ( LOOKAHEAD(3)
        ClassConstructorDecl(className) |
        LOOKAHEAD(3)
        ClassVarDecl() |
        LOOKAHEAD(3)
        ClassFuncDecl()
    )
)*
}

void ClassConstructorDecl (String name) : {Token t;}
{
t=<IDENTIFIER> {if (!t.image.equals(name)) return;
System.out.println("Found constructor of "+name);}
<CLOSE01>
(FuncArgDecl() (<COMMA> FuncArgDecl())*)?
<CLOSE02>
// Body
<CLOSE11>
<CLOSE12>
}

void ClassVarDecl () : {}
{
VarType() ArrayDecl()
<IDENTIFIER> (<COMMA> <IDENTIFIER>)*
(<EQUALS> VarAssign())?
<SEMICOLON>
}

void ClassFuncDecl () : {}
{
ReturnType() ArrayDecl()
<IDENTIFIER>
// Args
<CLOSE01>
(FuncArgDecl() (<COMMA> FuncArgDecl())*)?
<CLOSE02>
// Body
<CLOSE11>
<CLOSE12>
}

void FuncArgDecl () : {}
{
VarType() ArrayDecl() <IDENTIFIER>
}

void VarAssign () : {}
{
<INTEGER_CONSTANT> | <FLOAT_CONSTANT>
| <LOGIC_CONSTANT>
| <STRING_CONSTANT>
| <HEXADECIMAL_CONSTANT>
}

void ArrayDecl () : {}
{
(<CLOSE21> (<INT> | <IDENTIFIER>)? <CLOSE22>)*
}

void StorageType () : {}
{
(<STATIC>)? (<FINAL>)? (<SYNCHRONIZED>)?
}

void VarType () : {}
{
<INT> | <FLOAT> | <LONG> | <DOUBLE> | <SHORT> | <CHAR> | <BYTE> | <BOOLEAN> | <IDENTIFIER>
}

void ReturnType () : {}
{
<VOID> | VarType()
}

void Scope () : {}
{
<PRIVATE> | <PUBLIC> | <PROTECTED>
}
